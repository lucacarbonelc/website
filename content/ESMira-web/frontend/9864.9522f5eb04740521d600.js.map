{"version":3,"file":"9864.9522f5eb04740521d600.js","mappings":"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","sources":["webpack://ESMira/./src/frontend/ts/observable/ObservablePromise.ts","webpack://ESMira/./src/frontend/ts/pages/publicStatistics.tsx","webpack://ESMira/./src/frontend/ts/site/SectionContent.tsx","webpack://ESMira/./src/frontend/ts/widgets/ChartView.tsx"],"sourcesContent":["import {ObservableTypes} from \"./types/ObservableTypes\";\nimport {BaseObservable} from \"./BaseObservable\";\nimport { JsonTypes } from \"./types/JsonTypes\";\n\n/**\n * A observable Wrapper that can hold a Promise\n */\nexport class ObservablePromise<T> extends BaseObservable<Promise<T>> {\n\tprotected backingField: Promise<T>\n\t\n\tconstructor(value: Promise<T>, parent: BaseObservable<ObservableTypes> | null, key: string) {\n\t\tsuper(parent, key)\n\t\tthis.keyName = key\n\t\tthis.backingField = value\n\t}\n\t\n\tpublic reCalcIsDifferent(_: boolean = false): void {\n\t\t//do nothing\n\t}\n\t\n\tpublic createJson(): JsonTypes {\n        return \"\"\n    }\n\t\n\tpublic isDifferent(): boolean {\n\t\treturn false\n\t}\n\t\n\tpublic get(): Promise<any> {\n\t\treturn this.backingField\n\t}\n\tpublic set(value: Promise<T>, silently: boolean = false): void {\n\t\tthis.backingField = value\n\t\tif(!silently)\n\t\t\tthis.hasMutated(true, true)\n\t}\n\tpublic setValue(value: T, silently: boolean = false) {\n\t\tthis.set(Promise.resolve(value), silently)\n\t}\n}","import {SectionContent} from \"../site/SectionContent\";\nimport m, {Vnode} from \"mithril\";\nimport {Section} from \"../site/Section\";\nimport {Requests} from \"../singletons/Requests\";\nimport {FILE_STATISTICS} from \"../constants/urls\";\nimport {Study} from \"../data/study/Study\";\nimport {ChartView} from \"../widgets/ChartView\";\nimport {ObservablePromise} from \"../observable/ObservablePromise\";\nimport {LoadedStatistics} from \"../loader/csv/CsvLoaderCollectionFromCharts\";\n\nexport class Content extends SectionContent {\n\tprivate readonly publicStatisticsPromises: ObservablePromise<LoadedStatistics>[]\n\t\n\tpublic static preLoad(section: Section): Promise<any>[] {\n\t\treturn [ section.getStudyPromise() ]\n\t}\n\tconstructor(section: Section, study: Study) {\n\t\tsuper(section)\n\t\t\n\t\tconst promise = this.loadPublicStatistics()\n\t\tthis.publicStatisticsPromises = study.publicStatistics.charts.get().map(\n\t\t\t(_chart, index) => new ObservablePromise<LoadedStatistics>(promise, null, `publicChart${index}`)\n\t\t)\n\t}\n\t\n\tpublic title(): string {\n\t\treturn this.getStudyOrThrow().title.get()\n\t}\n\t\n\tprivate async loadPublicStatistics(): Promise<LoadedStatistics> {\n\t\tconst study = this.getStudyOrNull()\n\t\tlet accessKey: string\n\t\tif(study)\n\t\t\taccessKey = study.accessKeys.get().length ? study.accessKeys.get()[0].get() : \"\"\n\t\telse\n\t\t\taccessKey = this.getDynamic(\"accessKey\", \"\").get()\n\t\t\n\t\ttry {\n\t\t\tconst publicStatistics = await Requests.loadJson(\n\t\t\t\tFILE_STATISTICS\n\t\t\t\t\t.replace(\"%d\", this.getStaticInt(\"id\")?.toString() ?? \"-1\")\n\t\t\t\t\t.replace(\"%s\", accessKey)\n\t\t\t)\n\t\t\treturn { mainStatistics: publicStatistics }\n\t\t}\n\t\tcatch(e: any) {\n\t\t\tthis.section.loader.error(e.message || e)\n\t\t\treturn { mainStatistics: {} }\n\t\t}\n\t}\n\t\n\tpublic getView(): Vnode<any, any> {\n\t\tconst study = this.getStudyOrThrow()\n\t\treturn <div>\n\t\t\t{\n\t\t\t\tstudy.publicStatistics.charts.get().map((chartData, index) => {\n\t\t\t\t\treturn ChartView(chartData, this.publicStatisticsPromises[index])\n\t\t\t\t})\n\t\t\t}\n\t\t</div>\n\t}\n}","import m, {Vnode} from \"mithril\";\nimport {Section} from \"./Section\";\nimport {Study} from \"../data/study/Study\";\nimport {StaticValues} from \"./StaticValues\";\nimport {ObservablePrimitive} from \"../observable/ObservablePrimitive\";\nimport {Questionnaire} from \"../data/study/Questionnaire\";\nimport {DynamicValues} from \"./DynamicValues\";\nimport {PrimitiveType} from \"../observable/types/PrimitiveType\";\nimport {AccountPermissions} from \"../admin/AccountPermissions\";\nimport {AdminToolsInterface} from \"../admin/AdminToolsInterface\";\nimport {Admin} from \"../admin/Admin\";\n\nexport interface SectionAlternative {\n\ttitle: string\n\ttarget: string | false\n\theader?: boolean\n}\n\n/**\n * The dynamic content class of each section. Each section extends this class. SectionContent is a child of {@link Section} which takes care of loading and\n * displaying SectionContent.\n * Important: Changes to Observables in data.dataTypes will lead to {@link m.redraw()} (see {@link StudyLoader.constructor()}).\n * BUT, changes to the dom will happen asynchronously. In other words: The philosophy is, that {@link getView()} always works with fresh (not cached) data\n * and always constructs the full section (instead of just updating it). Mithril will take care of keeping track of changes and updates the dom when necessary.\n *\n * Method calls are guaranteed to be in this order:\n * 1. {@link preLoad()}\n * 2. {@link preInit()}\n * 3. {@link title()}, {@link titleExtra()}, {@link getView()}\n * Have a look at the implementation in {@link Section.load()} for more information\n */\nexport abstract class SectionContent {\n\tpublic readonly section: Section\n\t\n\tconstructor(section: Section) {\n\t\tthis.section = section\n\t}\n\t\n\t/**\n\t * Is always called before anything else.\n\t * @returns Promise array. The section will be in loading state and not other methods will be called as long as these Promises are loading\n\t */\n\tpublic static preLoad(_section: Section): Promise<any>[] {\n\t\treturn []\n\t}\n\t\n\t/**\n\t * Is guaranteed to run AFTER all promises in {@link preLoad()} are finished\n\t * @param _responses Holds the return values of each Promise from {@link preLoad()}\n\t */\n\tpublic preInit(... _responses: any): Promise<any> {\n\t\treturn Promise.resolve()\n\t}\n\tpublic hasAlternatives(): boolean {\n\t\treturn false\n\t}\n\tpublic getAlternatives(): SectionAlternative[] | Promise<SectionAlternative[]> | null {\n\t\treturn null\n\t}\n\t\n\tpublic abstract title(): string\n\t\n\tpublic titleExtra(): Vnode<any, any> | null {\n\t\treturn null\n\t}\n\t\n\t\n\tpublic getDynamic<T extends PrimitiveType>(key: keyof DynamicValues, defaultValue: T): ObservablePrimitive<T> {\n\t\treturn this.section.getDynamic(key, defaultValue)\n\t}\n\tpublic setDynamic<T extends PrimitiveType>(key: keyof DynamicValues, newValue: T) {\n\t\tthis.section.siteData.dynamicValues.setChild(key, newValue)\n\t}\n\tpublic getStaticInt<T extends StaticValues>(key: T): number | null {\n\t\treturn this.section.getStaticInt(key)\n\t}\n\tpublic getStaticString<T extends StaticValues>(key: T): string | null {\n\t\treturn this.section.getStaticString(key)\n\t}\n\tprotected getStudyOrNull(id: number = this.getStaticInt(\"id\") ?? -1): Study | null {\n\t\tconst studies = this.section.siteData.studyLoader.getStudies()\n\t\tif(id == -1)\n\t\t\treturn studies.getCount() == 1 ? (studies.getFirst() || null) : null\n\t\t\n\t\treturn studies.getEntry(id) ?? null\n\t}\n\tpublic getStudyOrThrow(id: number = this.getStaticInt(\"id\") ?? -1): Study {\n\t\tconst study = this.getStudyOrNull(id)\n\t\tif(!study)\n\t\t\tthrow new Error(`Study ${id} does not exist!`)\n\t\treturn study\n\t}\n\tprotected getQuestionnaireOrNull(qId: number = this.getStaticInt(\"qId\") ?? -1, study: Study | null = this.getStudyOrNull()): Questionnaire | null {\n\t\tif(!study)\n\t\t\treturn null\n\t\tconst questionnaires = this.getStudyOrThrow().questionnaires.get()\n\t\tfor(const questionnaire of questionnaires) {\n\t\t\tif(questionnaire.internalId.get() == qId)\n\t\t\t\treturn questionnaire\n\t\t}\n\t\treturn null\n\t}\n\tprotected getQuestionnaireOrThrow(qId: number = this.getStaticInt(\"qId\") ?? -1): Questionnaire {\n\t\tconst questionnaire = this.getQuestionnaireOrNull(qId, this.getStudyOrThrow())\n\t\tif(!questionnaire)\n\t\t\tthrow new Error(`Questionnaire ${qId} does not exist!`)\n\t\telse\n\t\t\treturn questionnaire\n\t}\n\t\n\tpublic getTools(): AdminToolsInterface {\n\t\treturn this.section.getTools()\n\t}\n\tpublic getAdmin(): Admin {\n\t\treturn this.section.getAdmin()\n\t}\n\t\n\tpublic hasPermission(name: keyof AccountPermissions, studyId: number): boolean {\n\t\treturn this.getAdmin().isLoggedIn() && (this.getTools().hasPermission(name, studyId) ?? false)\n\t}\n\t\n\tpublic getUrl(name: string, depth: number = this.section.depth): string {\n\t\treturn `${this.section.getHash(depth)}/${name}`\n\t}\n\tpublic goTo(target: string): void {\n\t\twindow.location.hash = \"#\"+target;\n\t}\n\tpublic newSection(target: string, depth: number = this.section.depth): void {\n\t\twindow.location.hash = depth == -1 ? target : `${this.section.getHash(depth)}/${target}`\n\t}\n\t\n\t\n\t/**\n\t * Remember: Values or references of observables should NOT be cached (also when the value is an observable itself)\n\t * It would lead to new values not being updated properly on {@link m.redraw()}\n\t *\n\t * Examples:\n\t * You can cache: {@link StudyLoader.studyCache}. Because this observable is readonly and will never be replaced\n\t * You can NOT cache {@link StudyLoader.studyCache.get()} or {@link getStudyOrThrow()} or {@link getStudy().questionnaires.get()[2]}.\n\t * \t\tBecause all study entries in StudyLoader might have been replaced or removed between {@link m.redraw()}\n\t *\n\t * You can cache: {@link SiteData.dynamicValues[\"accessKey\"]} because {@link Container} uses Singletons (see {@link Container.getOrCreateObs()})\n\t * You can not cache: {@link SiteData.dynamicValues[\"accessKey\"].get()} because its value might change\n\t *\n\t * In conclusion: {@link getView()} always needs to work with fresh values. Starting, for example, with {@link getStudyOrThrow()}\n\t */\n\tpublic abstract getView(): Vnode<any, any>\n\t\n\tpublic destroy(): void {\n\t\t//do nothing\n\t}\n}","import m, {Component, Vnode, VnodeDOM} from \"mithril\";\nimport {LoadedStatistics} from \"../loader/csv/CsvLoaderCollectionFromCharts\";\nimport {ChartJsBox} from \"../helpers/ChartJsBox\";\nimport {ObserverId} from \"../observable/BaseObservable\";\nimport {ChartData} from \"../data/study/ChartData\";\nimport {LoadingSpinner} from \"./LoadingSpinner\";\nimport {ObservablePromise} from \"../observable/ObservablePromise\";\n\ninterface ChartComponentOptions {\n\tpromise: ObservablePromise<LoadedStatistics>\n\tchart: ChartData\n\tclassName?: string //in case the parent has added a className that we need to include\n\tnoSort: boolean\n}\n\nclass ChartComponent implements Component<ChartComponentOptions, any> {\n\tprivate enabled: boolean = false\n\tprivate chart?: ChartData\n\tprivate chartView?: HTMLElement\n\tprivate chartViewBox?: ChartJsBox\n\tprivate promiseObserverId?: ObserverId\n\t\n\t\n\tprivate async drawGraph(chart: ChartData, promise: Promise<LoadedStatistics>, noSort: boolean): Promise<void> {\n\t\tthis.enabled = false\n\t\tm.redraw()\n\t\t\n\t\tconst data = await promise\n\t\tconst view = this.chartView\n\t\t\n\t\tif(!view)\n\t\t\treturn\n\t\twhile(view?.hasChildNodes()) {\n\t\t\tview.removeChild(view.lastChild!)\n\t\t}\n\t\t\n\t\tthis.chartViewBox = new ChartJsBox(view, data.mainStatistics, data.additionalStatistics ?? {}, chart, noSort)\n\t\tthis.enabled = true\n\t\tm.redraw()\n\t}\n\t\n\tpublic oncreate(vNode: VnodeDOM<ChartComponentOptions, any>): void {\n\t\tconst promise = vNode.attrs.promise\n\t\tconst chart = vNode.attrs.chart\n\t\tconst noSort = vNode.attrs.noSort\n\t\tthis.chart = chart\n\t\tthis.chartView = vNode.dom.getElementsByClassName(\"chartViewWindow\")[0] as HTMLElement\n\t\t\n\t\tthis.drawGraph(chart, promise.get(), noSort)\n\t\tthis.promiseObserverId = promise.addObserver(() => {\n\t\t\tthis.drawGraph(chart, promise.get(), noSort)\n\t\t})\n\t}\n\t\n\tpublic onupdate(vNode: VnodeDOM<ChartComponentOptions, any>): void {\n\t\t//when a section is replaced with another section with the same content (but from a different study), mithril js will not reload this ChartView but call onupdate instead\n\t\tconst promise = vNode.attrs.promise\n\t\tconst chart = vNode.attrs.chart\n\t\tconst noSort = vNode.attrs.noSort\n\t\t\n\t\tif(chart != this.chart) {\n\t\t\tthis.chart = chart\n\t\t\tthis.drawGraph(chart, promise.get(), noSort)\n\t\t\tthis.promiseObserverId?.removeObserver()\n\t\t\t\n\t\t\tthis.promiseObserverId = promise.addObserver(() => {\n\t\t\t\tthis.drawGraph(chart, promise.get(), noSort)\n\t\t\t})\n\t\t}\n\t}\n\t\n\tpublic onremove(): void {\n\t\tthis.promiseObserverId?.removeObserver()\n\t}\n\t\n\tpublic view(vNode: VnodeDOM<ChartComponentOptions, any>): Vnode<any, any> {\n\t\treturn <div class={`chartView center ${vNode.attrs.className ?? \"\"}`}>\n\t\t\t<div class={`chartViewWindow ${this.enabled ? \"fadeIn\" : \"\"}`}></div>\n\t\t\t{!this.enabled &&\n\t\t\t\tLoadingSpinner()\n\t\t\t}\n\t\t</div>\n\t}\n}\n\nexport function ChartView(chart: ChartData, promise: ObservablePromise<LoadedStatistics>, noSort: boolean = false) {\n\treturn m(ChartComponent, {\n\t\tchart: chart,\n\t\tpromise: promise,\n\t\tnoSort: noSort\n\t})\n}"],"names":["value","parent","key","keyName","backingField","reCalcIsDifferent","_","createJson","isDifferent","get","this","set","silently","hasMutated","setValue","Promise","resolve","section","study","promise","loadPublicStatistics","publicStatisticsPromises","publicStatistics","charts","map","_chart","index","preLoad","getStudyPromise","title","getStudyOrThrow","getStudyOrNull","accessKey","accessKeys","length","getDynamic","loadJson","replace","getStaticInt","toString","mainStatistics","loader","error","message","getView","chartData","_section","preInit","hasAlternatives","getAlternatives","titleExtra","defaultValue","setDynamic","newValue","siteData","dynamicValues","setChild","getStaticString","id","studies","studyLoader","getStudies","getCount","getFirst","getEntry","Error","getQuestionnaireOrNull","qId","questionnaires","questionnaire","internalId","getQuestionnaireOrThrow","getTools","getAdmin","hasPermission","name","studyId","isLoggedIn","getUrl","depth","getHash","goTo","target","window","location","hash","newSection","destroy","enabled","drawGraph","chart","noSort","data","view","chartView","hasChildNodes","removeChild","lastChild","chartViewBox","additionalStatistics","oncreate","vNode","attrs","dom","getElementsByClassName","promiseObserverId","addObserver","onupdate","removeObserver","onremove","class","className","ChartView","ChartComponent"],"sourceRoot":""}