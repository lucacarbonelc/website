{"version":3,"file":"7559.ae8e203d628d2c9455f1.js","mappings":"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","sources":["webpack://ESMira/./src/frontend/ts/merlin/merlinTokens.ts","webpack://ESMira/./src/frontend/ts/merlin/merlinScanner.ts","webpack://ESMira/./src/frontend/ts/merlin/merlinParser.ts","webpack://ESMira/./src/frontend/ts/widgets/CodeEditor.tsx","webpack://ESMira/./src/frontend/ts/widgets/DashElement.tsx","webpack://ESMira/./src/frontend/ts/widgets/DashRow.tsx","webpack://ESMira/./src/frontend/ts/widgets/NotCompatibleIcon.tsx"],"sourcesContent":["/*\nClass to represent Tokens in the Merlin scripting language. Used by the Scanner and Parser.\n*/\n\nexport class MerlinToken {\n\ttype: MerlinTokenType\n\tlexeme: string\n\tline: number\n\t\n\tconstructor(type: MerlinTokenType, lexeme: string, line: number) {\n\t\tthis.type = type\n\t\tthis.lexeme = lexeme\n\t\tthis.line = line\n\t}\n}\n\n/*\nEnum to represent the possible token types of a MerlinToken.\n*/\n\nexport enum MerlinTokenType {\n\t// Single character tokens\n\tLEFT_PAREN,\n\tRIGHT_PAREN,\n\tLEFT_BRACE,\n\tRIGHT_BRACE,\n\tLEFT_BRACKET,\n\tRIGHT_BRACKET,\n\tCOMMA,\n\tCOLON,\n\tSEMICOLON,\n\tDOT,\n\tMINUS,\n\tPLUS,\n\tSLASH,\n\tSTAR,\n\t\n\t// One and two character tokens\n\tDOT_DOT,\n\tEXCLAMATION,\n\tEXCLAMATION_EQUAL,\n\tEQUAL,\n\tEQUAL_EQUAL,\n\tGREATER,\n\tGREATER_EQUAL,\n\tLESS,\n\tLESS_EQUAL,\n\tGREATER_GREATER,\n\t\n\t// Literals\n\tIDENTIFIER,\n\tSTRING,\n\tNUMBER,\n\t\n\t// Keywords\n\tAND,\n\tELSE,\n\tELIF,\n\tFALSE,\n\tFUNCTION,\n\tFOR,\n\tIF,\n\tIN,\n\tINIT,\n\tNONE,\n\tOBJECT,\n\tOR,\n\tRETURN,\n\tTRUE,\n\tWHILE,\n\t\n\tEOF\n}","import {MerlinToken, MerlinTokenType} from \"./merlinTokens\"\n\n/*\nA Scanner/Tokenizer for the Merlin scripting language.\nIt can take in the source code as a string in its constructor turn it into an array of Tokens.\nAlso keeps track of scanning errors. This is modeled directly after the Kotlin Scanner implementation in ESMira-apps.\n*/\n\nexport class MerlinScanner {\n\tconstructor(public source: string) {}\n\t\n\tprivate start = 0\n\tprivate current = 0\n\tprivate line = 1\n\tprivate tokens = Array<MerlinToken>()\n\t\n\tpublic errors = Array<ScanningError>()\n\t\n\t\n\tpublic scanTokens(): Array<MerlinToken> {\n\t\twhile(!this.isAtEnd()) {\n\t\t\tthis.start = this.current\n\t\t\tthis.scanToken()\n\t\t}\n\t\t\n\t\tthis.tokens.push(new MerlinToken(MerlinTokenType.EOF, \"\", this.line))\n\t\treturn this.tokens\n\t}\n\t\n\tpublic hadErrors(): boolean {\n\t\treturn this.errors.length > 0\n\t}\n\t\n\tprivate scanToken(): void {\n\t\tconst c = this.advance()\n\t\tswitch(c) {\n\t\t\tcase \"(\":\n\t\t\t\tthis.addToken(MerlinTokenType.LEFT_PAREN);\n\t\t\t\tbreak;\n\t\t\tcase \")\":\n\t\t\t\tthis.addToken(MerlinTokenType.RIGHT_PAREN);\n\t\t\t\tbreak;\n\t\t\tcase \"{\":\n\t\t\t\tthis.addToken(MerlinTokenType.LEFT_BRACE);\n\t\t\t\tbreak;\n\t\t\tcase \"}\":\n\t\t\t\tthis.addToken(MerlinTokenType.RIGHT_BRACE);\n\t\t\t\tbreak;\n\t\t\tcase \"[\":\n\t\t\t\tthis.addToken(MerlinTokenType.LEFT_BRACKET);\n\t\t\t\tbreak;\n\t\t\tcase \"]\":\n\t\t\t\tthis.addToken(MerlinTokenType.RIGHT_BRACKET);\n\t\t\t\tbreak;\n\t\t\tcase \",\":\n\t\t\t\tthis.addToken(MerlinTokenType.COMMA);\n\t\t\t\tbreak;\n\t\t\tcase \":\":\n\t\t\t\tthis.addToken(MerlinTokenType.COLON);\n\t\t\t\tbreak;\n\t\t\tcase \";\":\n\t\t\t\tthis.addToken(MerlinTokenType.SEMICOLON);\n\t\t\t\tbreak;\n\t\t\tcase \"-\":\n\t\t\t\tthis.addToken(MerlinTokenType.MINUS);\n\t\t\t\tbreak;\n\t\t\tcase \"+\":\n\t\t\t\tthis.addToken(MerlinTokenType.PLUS);\n\t\t\t\tbreak;\n\t\t\tcase \"*\":\n\t\t\t\tthis.addToken(MerlinTokenType.STAR);\n\t\t\t\tbreak;\n\t\t\tcase \".\":\n\t\t\t\tif(this.match(\".\")) {\n\t\t\t\t\tthis.addToken(MerlinTokenType.DOT_DOT)\n\t\t\t\t} else {\n\t\t\t\t\tthis.addToken(MerlinTokenType.DOT)\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\tcase \"!\":\n\t\t\t\tif(this.match(\"=\")) {\n\t\t\t\t\tthis.addToken(MerlinTokenType.EXCLAMATION_EQUAL)\n\t\t\t\t} else {\n\t\t\t\t\tthis.addToken(MerlinTokenType.EXCLAMATION)\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\tcase \"=\":\n\t\t\t\tif(this.match(\"=\")) {\n\t\t\t\t\tthis.addToken(MerlinTokenType.EQUAL_EQUAL)\n\t\t\t\t} else {\n\t\t\t\t\tthis.addToken(MerlinTokenType.EQUAL)\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\tcase \"<\":\n\t\t\t\tif(this.match(\"=\")) {\n\t\t\t\t\tthis.addToken(MerlinTokenType.LESS_EQUAL)\n\t\t\t\t} else {\n\t\t\t\t\tthis.addToken(MerlinTokenType.LESS)\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\tcase \">\":\n\t\t\t\tif(this.match(\"=\")) {\n\t\t\t\t\tthis.addToken(MerlinTokenType.GREATER_EQUAL)\n\t\t\t\t} else if(this.match(\">\")) {\n\t\t\t\t\tthis.addToken(MerlinTokenType.GREATER_GREATER)\n\t\t\t\t} else {\n\t\t\t\t\tthis.addToken(MerlinTokenType.GREATER)\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\tcase \"/\":\n\t\t\t\tif(this.match(\"/\")) {\n\t\t\t\t\twhile(this.peek() != \"\\n\" && !this.isAtEnd())\n\t\t\t\t\t\tthis.advance()\n\t\t\t\t} else {\n\t\t\t\t\tthis.addToken(MerlinTokenType.SLASH)\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\tcase \" \":\n\t\t\tcase \"\\r\":\n\t\t\tcase \"\\t\":\n\t\t\t\tbreak\n\t\t\tcase \"\\n\":\n\t\t\t\tthis.line++;\n\t\t\t\tbreak;\n\t\t\tcase \"\\\"\":\n\t\t\t\tthis.string();\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif(this.isDigit(c)) {\n\t\t\t\t\tthis.number()\n\t\t\t\t} else if(this.isLetter(c)) {\n\t\t\t\t\tthis.identifier()\n\t\t\t\t} else {\n\t\t\t\t\tthis.errors.push(new ScanningError(this.line, `Unexpected character ${c}.`))\n\t\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate isAtEnd(): boolean {\n\t\treturn this.current >= this.source.length\n\t}\n\t\n\tprivate advance(): string {\n\t\treturn this.source.charAt(this.current++)\n\t}\n\t\n\tprivate addToken(type: MerlinTokenType) {\n\t\tconst text = this.source.substring(this.start, this.current)\n\t\tthis.tokens.push(new MerlinToken(type, text, this.line))\n\t}\n\t\n\tprivate match(expected: string): boolean {\n\t\tif(this.isAtEnd()) return false\n\t\tif(this.source.charAt(this.current) != expected) return false\n\t\tthis.current++\n\t\treturn true\n\t}\n\t\n\tprivate peek(): string {\n\t\tif(this.isAtEnd()) return \"\\0\"\n\t\treturn this.source.charAt(this.current)\n\t}\n\t\n\tprivate peekNext(): string {\n\t\tif(this.current + 1 >= this.source.length) return \"\\0\"\n\t\treturn this.source.charAt(this.current + 1)\n\t}\n\t\n\tprivate string() {\n\t\tconst startLine = this.line\n\t\twhile(this.peek() != \"\\\"\" && !this.isAtEnd()) {\n\t\t\tif(this.peek() == \"\\n\") this.line++\n\t\t\tthis.advance()\n\t\t}\n\t\t\n\t\tif(this.isAtEnd()) {\n\t\t\tthis.errors.push(new ScanningError(startLine, `Unterminated string, starting at line ${startLine}`))\n\t\t}\n\t\t\n\t\tthis.advance()\n\t\tthis.addToken(MerlinTokenType.STRING)\n\t}\n\t\n\tprivate number(): void {\n\t\twhile(this.isDigit(this.peek()))\n\t\t\tthis.advance()\n\t\t\n\t\tif(this.peek() == \".\" && this.isDigit(this.peekNext())) {\n\t\t\tthis.advance()\n\t\t\twhile(this.isDigit(this.peek()))\n\t\t\t\tthis.advance()\n\t\t}\n\t\t\n\t\tthis.addToken(MerlinTokenType.NUMBER)\n\t}\n\t\n\tprivate identifier(): void {\n\t\twhile(this.isLetter(this.peek()) || this.isDigit(this.peek()))\n\t\t\tthis.advance()\n\t\t\n\t\tconst text = this.source.substring(this.start, this.current)\n\t\tconst type = keywords[text] || MerlinTokenType.IDENTIFIER\n\t\tthis.addToken(type)\n\t}\n\t\n\tprivate isLetter(c: string): boolean {\n\t\treturn /[a-z]|[A-Z]|_/.test(c)\n\t}\n\t\n\tprivate isDigit(c: string): boolean {\n\t\treturn /[0-9]/.test(c)\n\t}\n\t\n}\n\nexport class ScanningError {\n\tconstructor(public line: number, public message: string) {}\n}\n\nconst keywords: { [key: string]: MerlinTokenType } = {\n\t\"and\": MerlinTokenType.AND,\n\t\"else\": MerlinTokenType.ELSE,\n\t\"elif\": MerlinTokenType.ELIF,\n\t\"false\": MerlinTokenType.FALSE,\n\t\"function\": MerlinTokenType.FUNCTION,\n\t\"for\": MerlinTokenType.FOR,\n\t\"if\": MerlinTokenType.IF,\n\t\"in\": MerlinTokenType.IN,\n\t\"init\": MerlinTokenType.INIT,\n\t\"none\": MerlinTokenType.NONE,\n\t\"object\": MerlinTokenType.OBJECT,\n\t\"or\": MerlinTokenType.OR,\n\t\"return\": MerlinTokenType.RETURN,\n\t\"true\": MerlinTokenType.TRUE,\n\t\"while\": MerlinTokenType.WHILE\n}","import {MerlinToken, MerlinTokenType} from \"./merlinTokens\"\n\n/*\nParser for the Merlin scripting language.\nThe constructor takes in an array of MerlinTokens generated by the Scanner, and can parse them into an Abstract Syntax Tree.\nThis parser uses recursive descent parsing and is a direct translation of the parser in ESMira-apps, which is implemented in Kotlin.\nWhile this parser can generate an AST that would be ready for interpreting, this parser was only created for it's capability of gathering parsing errors in order to display them in a script editor.\n*/\n\nexport class MerlinParser {\n\tconstructor(private tokens: Array<MerlinToken>) {\n\t}\n\t\n\tpublic errors = Array<ParseError>()\n\tprivate current = 0\n\t\n\t\n\tpublic parse(): Array<Stmt | null> {\n\t\tconst statements = Array<Stmt | null>()\n\t\twhile(!this.isAtEnd())\n\t\t\tstatements.push(this.declaration())\n\t\t\n\t\treturn statements\n\t}\n\t\n\tpublic hadErrors(): boolean {\n\t\treturn this.errors.length > 0\n\t}\n\t\n\tprivate declaration(): Stmt | null {\n\t\ttry {\n\t\t\tif(this.match([MerlinTokenType.FUNCTION]))\n\t\t\t\treturn this.function()\n\t\t\treturn this.statement()\n\t\t} catch(e: unknown) {\n\t\t\tif(e instanceof ParseError) {\n\t\t\t\tthis.errors.push(e)\n\t\t\t\tthis.synchronize()\n\t\t\t}\n\t\t\treturn null\n\t\t}\n\t}\n\t\n\tprivate function(): FunctionStmt {\n\t\tconst name = this.consume(MerlinTokenType.IDENTIFIER, \"Expecting a function name.\")\n\t\tthis.consume(MerlinTokenType.LEFT_PAREN, \"Expect '(' after function name.\")\n\t\tconst parameters = Array<MerlinToken>()\n\t\tif(!this.check(MerlinTokenType.RIGHT_PAREN)) {\n\t\t\tdo {\n\t\t\t\tparameters.push(this.consume(MerlinTokenType.IDENTIFIER, \"Expect parameter name.\"))\n\t\t\t} while(this.match([MerlinTokenType.COMMA]))\n\t\t}\n\t\tthis.consume(MerlinTokenType.RIGHT_PAREN, \"Expect ')' after function parameters.\")\n\t\tthis.consume(MerlinTokenType.LEFT_BRACE, \"Expect '{' before function body.\")\n\t\tconst body = this.block()\n\t\treturn new FunctionStmt(name, parameters, body)\n\t}\n\t\n\tprivate block(): Array<Stmt | null> {\n\t\tconst statements = Array<Stmt | null>()\n\t\t\n\t\twhile(!this.check(MerlinTokenType.RIGHT_BRACE) && !this.isAtEnd())\n\t\t\tstatements.push(this.declaration())\n\t\tthis.consume(MerlinTokenType.RIGHT_BRACE, \"Expect '}' after block.\")\n\t\treturn statements\n\t}\n\t\n\tprivate statement(): Stmt {\n\t\tif(this.match([MerlinTokenType.FOR])) return this.forStatement()\n\t\tif(this.match([MerlinTokenType.IF])) return this.ifStatement()\n\t\tif(this.match([MerlinTokenType.RETURN])) return this.returnStatement()\n\t\tif(this.match([MerlinTokenType.WHILE])) return this.whileStatement()\n\t\tif(this.match([MerlinTokenType.INIT])) return this.initStatement()\n\t\tif(this.match([MerlinTokenType.LEFT_BRACE])) return new BlockStmt(this.block())\n\t\t\n\t\treturn this.assignmentStatement()\n\t}\n\t\n\tprivate forStatement(): Stmt {\n\t\tthis.consume(MerlinTokenType.LEFT_PAREN, \"Expect '(' after 'for'.\")\n\t\t\n\t\tconst variable = this.consume(MerlinTokenType.IDENTIFIER, \"Expect variable name for 'for' loop.\")\n\t\tthis.consume(MerlinTokenType.IN, \"Expect 'in' after variable name in 'for' loop.\")\n\t\tconst iterable = this.expression()\n\t\tthis.consume(MerlinTokenType.RIGHT_PAREN, \"Expect ')' after 'for' range.\")\n\t\tconst body = this.statement()\n\t\t\n\t\treturn new ForStmt(variable, iterable, body)\n\t}\n\t\n\tprivate ifStatement(): Stmt {\n\t\tconst branches = Array<Branch>()\n\t\tdo {\n\t\t\tthis.consume(MerlinTokenType.LEFT_PAREN, \"Expect '(' after 'if'.\")\n\t\t\tconst condition = this.expression()\n\t\t\tthis.consume(MerlinTokenType.RIGHT_PAREN, \"Expect ')' after 'if' condition.\")\n\t\t\tconst thenBranch = this.statement()\n\t\t\tbranches.push(new Branch(condition, thenBranch))\n\t\t} while(this.match([MerlinTokenType.ELIF]))\n\t\tlet elseBranch = undefined\n\t\tif(this.match([MerlinTokenType.ELSE]))\n\t\t\telseBranch = this.statement()\n\t\treturn new IfStmt(branches, elseBranch)\n\t}\n\t\n\tprivate returnStatement(): Stmt {\n\t\tconst keyword = this.previous()\n\t\tlet value = undefined\n\t\tif(!this.check(MerlinTokenType.SEMICOLON))\n\t\t\tvalue = this.expression()\n\t\tthis.consume(MerlinTokenType.SEMICOLON, \"Expect ';' after return statement.\")\n\t\treturn new ReturnStmt(keyword, value)\n\t}\n\t\n\tprivate whileStatement(): Stmt {\n\t\tthis.consume(MerlinTokenType.LEFT_PAREN, \"Expect '(' after 'while'.\")\n\t\tconst condition = this.expression()\n\t\tthis.consume(MerlinTokenType.RIGHT_PAREN, \"Expect ')' after 'while' condition.\")\n\t\tconst body = this.statement()\n\t\t\n\t\treturn new WhileStmt(condition, body)\n\t}\n\t\n\tprivate assignmentStatement(): Stmt {\n\t\tconst expr = this.expression()\n\t\t\n\t\tif(this.match([MerlinTokenType.EQUAL])) {\n\t\t\tconst equals = this.previous()\n\t\t\tconst value = this.expression()\n\t\t\t\n\t\t\tif(expr instanceof VariableExpr) {\n\t\t\t\tthis.consume(MerlinTokenType.SEMICOLON, \"Expect ';' after assign statement.\")\n\t\t\t\treturn new AssignStmt(expr.name, value)\n\t\t\t} else if(expr instanceof ObjectGetExpr) {\n\t\t\t\tthis.consume(MerlinTokenType.SEMICOLON, \"Expect ';' after assgin statement.\")\n\t\t\t\treturn new ObjectSetStmt(expr.obj, expr.name, value)\n\t\t\t} else if(expr instanceof ArrayGetExpr) {\n\t\t\t\tthis.consume(MerlinTokenType.SEMICOLON, \"Expect ';' after assign statement.\")\n\t\t\t\treturn new ArraySetStmt(expr.bracket, expr.arr, expr.index, value)\n\t\t\t} else {\n\t\t\t\tthrow new ParseError(equals, \"Invalid assignment target.\")\n\t\t\t}\n\t\t}\n\t\t\n\t\tthis.consume(MerlinTokenType.SEMICOLON, \"Expect ';' after expression statement.\")\n\t\treturn new ExpressionStmt(expr)\n\t}\n\t\n\tprivate initStatement(): Stmt {\n\t\tthis.consume(MerlinTokenType.LEFT_BRACE, \"Expect '{' after 'init'.\")\n\t\tconst statements = this.block()\n\t\treturn new InitStmt(statements)\n\t}\n\t\n\tprivate expression(): Expr {\n\t\treturn this.or()\n\t}\n\t\n\tprivate or(): Expr {\n\t\tlet expr = this.and()\n\t\t\n\t\twhile(this.match([MerlinTokenType.OR])) {\n\t\t\tconst operator = this.previous()\n\t\t\tconst right = this.and()\n\t\t\texpr = new LogicalExpr(expr, operator, right)\n\t\t}\n\t\t\n\t\treturn expr\n\t}\n\t\n\tprivate and(): Expr {\n\t\tlet expr = this.equality()\n\t\t\n\t\twhile(this.match([MerlinTokenType.AND])) {\n\t\t\tconst operator = this.previous()\n\t\t\tconst right = this.equality()\n\t\t\texpr = new LogicalExpr(expr, operator, right)\n\t\t}\n\t\t\n\t\treturn expr\n\t}\n\t\n\tprivate equality(): Expr {\n\t\tlet expr = this.comparison()\n\t\t\n\t\twhile(this.match([MerlinTokenType.EXCLAMATION_EQUAL, MerlinTokenType.EQUAL_EQUAL])) {\n\t\t\tconst operator = this.previous()\n\t\t\tconst right = this.comparison()\n\t\t\texpr = new BinaryExpr(expr, operator, right)\n\t\t}\n\t\t\n\t\treturn expr\n\t}\n\t\n\tprivate comparison(): Expr {\n\t\tlet expr = this.term()\n\t\t\n\t\twhile(this.match([MerlinTokenType.GREATER, MerlinTokenType.GREATER_EQUAL, MerlinTokenType.LESS, MerlinTokenType.LESS_EQUAL])) {\n\t\t\tconst operator = this.previous()\n\t\t\tconst right = this.term()\n\t\t\texpr = new BinaryExpr(expr, operator, right)\n\t\t}\n\t\t\n\t\treturn expr\n\t}\n\t\n\tprivate term(): Expr {\n\t\tlet expr = this.factor()\n\t\t\n\t\twhile(this.match([MerlinTokenType.MINUS, MerlinTokenType.PLUS, MerlinTokenType.DOT_DOT])) {\n\t\t\tconst operator = this.previous()\n\t\t\tconst right = this.factor()\n\t\t\texpr = new BinaryExpr(expr, operator, right)\n\t\t}\n\t\t\n\t\treturn expr\n\t}\n\t\n\tprivate factor(): Expr {\n\t\tlet expr = this.sequence()\n\t\t\n\t\twhile(this.match([MerlinTokenType.SLASH, MerlinTokenType.STAR])) {\n\t\t\tconst operator = this.previous()\n\t\t\tconst right = this.sequence()\n\t\t}\n\t\t\n\t\treturn expr\n\t}\n\t\n\tprivate sequence(): Expr {\n\t\tlet expr = this.unary()\n\t\t\n\t\tif(this.match([MerlinTokenType.COLON])) {\n\t\t\tconst colon = this.previous()\n\t\t\tconst sequenceEnd = this.unary()\n\t\t\tlet sequenceStep = undefined\n\t\t\tif(this.match([MerlinTokenType.COLON]))\n\t\t\t\tsequenceStep = this.unary()\n\t\t\t\n\t\t\treturn new SequenceExpr(expr, colon, sequenceEnd, sequenceStep)\n\t\t}\n\t\t\n\t\treturn expr\n\t}\n\t\n\tprivate unary(): Expr {\n\t\tif(this.match([MerlinTokenType.EXCLAMATION, MerlinTokenType.MINUS])) {\n\t\t\tconst operator = this.previous()\n\t\t\tconst right = this.unary()\n\t\t\treturn new UnaryExpr(operator, right)\n\t\t}\n\t\t\n\t\treturn this.callChain()\n\t}\n\t\n\tprivate callChain(): Expr {\n\t\tlet expr = this.call()\n\t\t\n\t\twhile(this.match([MerlinTokenType.GREATER_GREATER])) {\n\t\t\tconst nextFunc = this.call()\n\t\t\tif(!(nextFunc instanceof CallExpr)) {\n\t\t\t\tthrow new ParseError(this.previous(), \"Expecting function call after '>>'.\")\n\t\t\t}\n\t\t\texpr = new CallExpr(nextFunc.callee, nextFunc.paren, [expr, ...nextFunc.args])\n\t\t}\n\t\t\n\t\treturn expr\n\t}\n\t\n\tprivate call(): Expr {\n\t\tlet expr = this.value()\n\t\t\n\t\twhile(true) {\n\t\t\tif(this.match([MerlinTokenType.LEFT_PAREN])) {\n\t\t\t\texpr = this.finishCall(expr)\n\t\t\t} else if(this.match([MerlinTokenType.DOT])) {\n\t\t\t\tconst name = this.consume(MerlinTokenType.IDENTIFIER, \"Exping a property name after '.'.\")\n\t\t\t\texpr = new ObjectGetExpr(expr, name)\n\t\t\t} else if(this.match([MerlinTokenType.LEFT_BRACKET])) {\n\t\t\t\tconst bracket = this.previous()\n\t\t\t\tconst index = this.expression()\n\t\t\t\tthis.consume(MerlinTokenType.RIGHT_BRACKET, \"Expecting ']' after array index.\")\n\t\t\t\texpr = new ArrayGetExpr(bracket, expr, index)\n\t\t\t} else {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn expr\n\t}\n\t\n\tprivate finishCall(callee: Expr): Expr {\n\t\tif(!(callee instanceof VariableExpr)) {\n\t\t\tthrow new ParseError(this.previous(), \"Invalid identifier for function call.\")\n\t\t}\n\t\tconst args = Array<Expr>()\n\t\tif(!this.check(MerlinTokenType.RIGHT_PAREN)) {\n\t\t\tdo {\n\t\t\t\targs.push(this.expression())\n\t\t\t} while(this.match([MerlinTokenType.COMMA]))\n\t\t}\n\t\tconst paren = this.consume(MerlinTokenType.RIGHT_PAREN, \"Expect ')' after function call arguments.\")\n\t\t\n\t\treturn new CallExpr(callee.name, paren, args)\n\t}\n\t\n\tprivate value(): Expr {\n\t\tif(this.match([MerlinTokenType.LEFT_BRACKET])) {\n\t\t\tconst elements = Array<Expr>()\n\t\t\tif(!this.check(MerlinTokenType.RIGHT_BRACKET)) {\n\t\t\t\tdo {\n\t\t\t\t\telements.push(this.expression())\n\t\t\t\t} while(this.match([MerlinTokenType.COMMA]))\n\t\t\t}\n\t\t\tconst bracket = this.consume(MerlinTokenType.RIGHT_BRACKET, \"Expect ']' after array expression.\")\n\t\t\t\n\t\t\treturn new ArrayExpr(bracket, elements)\n\t\t}\n\t\t\n\t\treturn this.primary()\n\t}\n\t\n\tprivate primary(): Expr {\n\t\tif(this.match([\n\t\t\tMerlinTokenType.FALSE,\n\t\t\tMerlinTokenType.TRUE,\n\t\t\tMerlinTokenType.NUMBER,\n\t\t\tMerlinTokenType.STRING,\n\t\t\tMerlinTokenType.NONE\n\t\t])) return new LiteralExpr(this.previous())\n\t\tif(this.match([MerlinTokenType.OBJECT])) return new ObjectExpr(this.previous())\n\t\tif(this.match([MerlinTokenType.IDENTIFIER])) return new VariableExpr(this.previous())\n\t\t\n\t\tif(this.match([MerlinTokenType.LEFT_PAREN])) {\n\t\t\tconst expr = this.expression()\n\t\t\tthis.consume(MerlinTokenType.RIGHT_PAREN, \"Unmatched '('. Expecting ')' after expression.\")\n\t\t\treturn new GroupingExpr(expr)\n\t\t}\n\t\t\n\t\tthrow new ParseError(this.peek(), \"Expecting expression.\")\n\t}\n\t\n\tprivate advance(): MerlinToken {\n\t\tif(!this.isAtEnd())\n\t\t\tthis.current++\n\t\treturn this.previous()\n\t}\n\t\n\tprivate isAtEnd(): boolean {\n\t\treturn this.peek().type == MerlinTokenType.EOF\n\t}\n\t\n\tprivate peek(): MerlinToken {\n\t\treturn this.tokens[this.current]\n\t}\n\t\n\tprivate previous(): MerlinToken {\n\t\treturn this.tokens[this.current - 1]\n\t}\n\t\n\tprivate match(types: Array<MerlinTokenType>): boolean {\n\t\treturn types.some(element => {\n\t\t\tif(this.check(element)) {\n\t\t\t\tthis.advance()\n\t\t\t\treturn true\n\t\t\t}\n\t\t\treturn false\n\t\t})\n\t}\n\t\n\tprivate check(type: MerlinTokenType): boolean {\n\t\tif(this.isAtEnd()) return false\n\t\treturn this.peek().type == type\n\t}\n\t\n\tprivate consume(type: MerlinTokenType, message: string): MerlinToken {\n\t\tif(this.check(type)) return this.advance()\n\t\tthrow new ParseError(this.peek(), message)\n\t}\n\t\n\tprivate synchronize(): void {\n\t\tthis.advance()\n\t\t\n\t\twhile(!this.isAtEnd()) {\n\t\t\tif(this.previous().type == MerlinTokenType.SEMICOLON) return\n\t\t\t\n\t\t\tswitch(this.peek().type) {\n\t\t\t\tcase MerlinTokenType.FUNCTION:\n\t\t\t\tcase MerlinTokenType.FOR:\n\t\t\t\tcase MerlinTokenType.IF:\n\t\t\t\tcase MerlinTokenType.WHILE:\n\t\t\t\tcase MerlinTokenType.RETURN:\n\t\t\t\t\treturn\n\t\t\t}\n\t\t\tthis.advance()\n\t\t}\n\t}\n\t\n\t\n}\n\nexport class ParseError {\n\tconstructor(public token: MerlinToken, public message: string) {\n\t}\n}\n\n// Instructions\n\nclass Expr {\n}\n\nclass Stmt {\n}\n\nclass ArraySetStmt extends Stmt {\n\tconstructor(public bracket: MerlinToken, public arr: Expr, public index: Expr, public value: Expr) {\n\t\tsuper()\n\t}\n}\n\nclass AssignStmt extends Stmt {\n\tconstructor(public name: MerlinToken, public value: Expr) {\n\t\tsuper()\n\t}\n}\n\nclass BlockStmt extends Stmt {\n\tconstructor(public statements: Array<Stmt | null>) {\n\t\tsuper()\n\t}\n}\n\nclass ExpressionStmt extends Stmt {\n\tconstructor(public expression: Expr) {\n\t\tsuper()\n\t}\n}\n\nclass ForStmt extends Stmt {\n\tconstructor(public varName: MerlinToken, public iterable: Expr, public body: Stmt) {\n\t\tsuper()\n\t}\n}\n\nclass FunctionStmt extends Stmt {\n\tconstructor(public name: MerlinToken, public params: Array<MerlinToken>, public body: Array<Stmt | null>) {\n\t\tsuper()\n\t}\n}\n\nclass Branch {\n\tconstructor(public condition: Expr, public thenBranch: Stmt) {\n\t}\n}\n\nclass IfStmt extends Stmt {\n\tconstructor(public branches: Array<Branch>, public elseBranch?: Stmt) {\n\t\tsuper()\n\t}\n}\n\nclass InitStmt extends Stmt {\n\tconstructor(public statements: Array<Stmt | null>) {\n\t\tsuper()\n\t}\n}\n\nclass ObjectSetStmt extends Stmt {\n\tconstructor(public object: Expr, public name: MerlinToken, public value: Expr) {\n\t\tsuper()\n\t}\n}\n\nclass ReturnStmt extends Stmt {\n\tconstructor(public keyword: MerlinToken, public value?: Expr) {\n\t\tsuper()\n\t}\n}\n\nclass WhileStmt extends Stmt {\n\tconstructor(public condition: Expr, public body: Stmt) {\n\t\tsuper()\n\t}\n}\n\nclass ArrayExpr extends Expr {\n\tconstructor(public bracket: MerlinToken, public elements: Array<Expr>) {\n\t\tsuper()\n\t}\n}\n\nclass ArrayGetExpr extends Expr {\n\tconstructor(public bracket: MerlinToken, public arr: Expr, public index: Expr) {\n\t\tsuper()\n\t}\n}\n\nclass BinaryExpr extends Expr {\n\tconstructor(public left: Expr, public operator: MerlinToken, public right: Expr) {\n\t\tsuper()\n\t}\n}\n\nclass CallExpr extends Expr {\n\tconstructor(public callee: MerlinToken, public paren: MerlinToken, public args: Array<Expr>) {\n\t\tsuper()\n\t}\n}\n\nclass GroupingExpr extends Expr {\n\tconstructor(public expression: Expr) {\n\t\tsuper()\n\t}\n}\n\nclass LiteralExpr extends Expr {\n\tconstructor(public value: MerlinToken) {\n\t\tsuper()\n\t}\n}\n\nclass LogicalExpr extends Expr {\n\tconstructor(public left: Expr, public operator: Expr, public right: Expr) {\n\t\tsuper()\n\t}\n}\n\nclass ObjectExpr extends Expr {\n\tconstructor(public keyword: MerlinToken) {\n\t\tsuper()\n\t}\n}\n\nclass ObjectGetExpr extends Expr {\n\tconstructor(public obj: Expr, public name: MerlinToken) {\n\t\tsuper()\n\t}\n}\n\nclass SequenceExpr extends Expr {\n\tconstructor(public start: Expr, public colon: MerlinToken, public end: Expr, public step?: Expr) {\n\t\tsuper()\n\t}\n}\n\nclass UnaryExpr extends Expr {\n\tconstructor(public operator: MerlinToken, public right: Expr) {\n\t\tsuper()\n\t}\n}\n\nclass VariableExpr extends Expr {\n\tconstructor(public name: MerlinToken) {\n\t\tsuper()\n\t}\n}","import m, {Component, Vnode, VnodeDOM} from \"mithril\"\nimport {BaseObservable} from \"../observable/BaseObservable\"\nimport {basicSetup, EditorView} from \"codemirror\"\nimport {EditorState} from \"@codemirror/state\"\nimport {ViewUpdate, keymap} from \"@codemirror/view\"\nimport {linter, Diagnostic, lintGutter} from \"@codemirror/lint\"\nimport {indentWithTab} from \"@codemirror/commands\"\nimport {MerlinScanner} from \"../merlin/merlinScanner\"\nimport {MerlinParser} from \"../merlin/merlinParser\"\n\n/*\nThis is a Code Editor component that is intended for writing Merlin code.\nThe linter used in this editor can use the TS-implementation of the Merlin Scanner and Parser from ESMira-apps to find scanning/parsing errors and display them in the editor.\n*/\n\ninterface CodeEditorComponentOptions {\n\tobs: BaseObservable<string>\n}\n\nclass CodeEditorComponent implements Component<CodeEditorComponentOptions, any> {\n\tprivate obs?: BaseObservable<string>\n\tprivate lastValue: string = \"\"\n\tprivate editor?: EditorView\n\t\n\tprivate extensions = [\n\t\tbasicSetup,\n\t\tkeymap.of([indentWithTab]),\n\t\tEditorView.updateListener.of((update: ViewUpdate) => {\n\t\t\tthis.obs?.set(update.state.doc.toString())\n\t\t}),\n\t\tlintGutter(),\n\t\tmerlinLinter\n\t]\n\t\n\tpublic oncreate(vNode: VnodeDOM<CodeEditorComponentOptions, any>): void {\n\t\tconst obs = vNode.attrs.obs\n\t\tthis.obs = obs\n\t\tthis.lastValue = obs.get()\n\t\tthis.createEditor(vNode.dom, this.obs)\n\t}\n\t\n\tpublic onupdate(vNode: VnodeDOM<CodeEditorComponentOptions, any>): void {\n\t\tconst newValue = vNode.attrs.obs.get()\n\t\t\n\t\tif(this.obs != vNode.attrs.obs) {\n\t\t\tif(this.editor)\n\t\t\t\tthis.editor.dom.remove()\n\t\t\tthis.obs = vNode.attrs.obs\n\t\t\tthis.createEditor(vNode.dom, this.obs)\n\t\t} else if(this.lastValue != newValue) {\n\t\t\tthis.lastValue = newValue\n\t\t\tthis.editor?.state.update({changes: {from: 0, to: this.editor.state.doc.length, insert: newValue}})\n\t\t}\n\t}\n\t\n\tpublic createEditor(parent: Element, obs: BaseObservable<string>): void {\n\t\tconst initialState = EditorState.create({\n\t\t\tdoc: obs.get(),\n\t\t\textensions: this.extensions\n\t\t})\n\t\tconst editor = new EditorView({\n\t\t\tparent: parent,\n\t\t\tstate: initialState\n\t\t})\n\t\tthis.editor = editor\n\t}\n\t\n\tpublic view(): Vnode<any, any> {\n\t\treturn <div id=\"codeEditor\"></div>\n\t}\n}\n\nconst merlinLinter = linter(view => {\n\tlet diagnostics: Diagnostic[] = []\n\tconst doc = view.state.doc\n\tconst source = doc.toString()\n\tconst scanner = new MerlinScanner(source)\n\tconst tokens = scanner.scanTokens()\n\tif(scanner.hadErrors()) {\n\t\tscanner.errors.forEach(e => {\n\t\t\tconst lineOffsets = doc.line(e.line)\n\t\t\tdiagnostics.push({\n\t\t\t\tfrom: lineOffsets.from,\n\t\t\t\tto: lineOffsets.to,\n\t\t\t\tseverity: \"error\",\n\t\t\t\tmessage: e.message\n\t\t\t})\n\t\t})\n\t\treturn diagnostics\n\t}\n\tconst parser = new MerlinParser(tokens)\n\tparser.parse()\n\tif(parser.hadErrors()) {\n\t\tparser.errors.forEach(e => {\n\t\t\tconst lineOffsets = doc.line(e.token.line)\n\t\t\tdiagnostics.push({\n\t\t\t\tfrom: lineOffsets.from,\n\t\t\t\tto: lineOffsets.to,\n\t\t\t\tseverity: \"error\",\n\t\t\t\tmessage: e.message\n\t\t\t})\n\t\t})\n\t}\n\treturn diagnostics\n})\n\nexport function CodeEditor(obs: BaseObservable<string>): Vnode<any, any> {\n\treturn m(CodeEditorComponent, {obs: obs})\n}","import m, {Vnode} from \"mithril\"\nimport {NotCompatibleIcon, PossibleDevices} from \"./NotCompatibleIcon\";\n\ntype DashTemplateOptions = {\n\ttitle: string\n\ticon?: Vnode<any, any>\n\tnoCompatibilityIcon?: PossibleDevices[]\n\tmsg?: string | Vnode<any, any>\n\tinnerLinkTitle?: string\n\tinnerLinkHref?: string\n}\n\ntype DashContainerOptions = \"stretched\" | \"cramped\" | \"vertical\" | \"horizontal\" | null\nexport type DashViewOptions = {\n\tdisabled?: boolean\n\tonclick?: (e: MouseEvent) => void\n\thref?: string\n\tshowAsClickable?: boolean\n\tfloating?: boolean\n\tfloatingRight?: boolean\n\thighlight?: boolean\n\tsmall?: boolean\n\ttemplate?: DashTemplateOptions\n\tcontent?: Vnode<any, any>\n}\n\nfunction DashTemplateView(options: DashTemplateOptions): Vnode<any, any> {\n\treturn (\n\t\t<div>\n\t\t\t{(options.icon || options.noCompatibilityIcon) &&\n\t\t\t\t<div class=\"dashIcon\">\n\t\t\t\t\t{options.icon}\n\t\t\t\t\t{options.noCompatibilityIcon && NotCompatibleIcon(... options.noCompatibilityIcon)}\n\t\t\t\t</div>\n\t\t\t}\n\t\t\t\n\t\t\t<div class=\"dashTitle\">{options.title}</div>\n\t\t\t{options.msg && <p class=\"dashMsg\">{options.msg}</p>}\n\t\t\t{options.innerLinkTitle && options.innerLinkHref && <a class=\"link\" href={options.innerLinkHref}>{options.innerLinkTitle}</a>}\n\t\t</div>\n\t)\n}\n\nfunction DashElementView(options: DashViewOptions): Vnode<any, any> {\n\tlet classString = \"dashEl\"\n\tif(options.floatingRight)\n\t\tclassString += \" floating right\"\n\telse if(options.floating)\n\t\tclassString += \" floating\"\n\t\n\tif(options.small)\n\t\tclassString += \" small\"\n\tif(options.highlight)\n\t\tclassString += \" highlight\"\n\tif(options.disabled)\n\t\tclassString += \" disabled\"\n\t\n\tlet view: Vnode<any, any>\n\tif(options.content)\n\t\tview = options.content\n\telse if(options.template)\n\t\tview = DashTemplateView(options.template)\n\telse\n\t\tview = <div class=\"highlight\">Missing Dash Information</div>\n\t\n\tif(options.href) {\n\t\treturn <a target={options.href.startsWith(\"http\") ? \"_blank\" : \"\"} class={`${classString} dashLink`} href={options.href}>{view}</a>\n\t}\n\telse if(options.onclick)\n\t\treturn <a class={`${classString} dashLink`} onclick={options.onclick}>{view}</a>\n\telse if(options.showAsClickable)\n\t\treturn <a class={`${classString} dashLink`}>{view}</a>\n\telse {\n\t\tview.attrs[\"className\"] = `${classString} ${view.attrs.hasOwnProperty(\"className\") ? view.attrs[\"className\"] : \"\"}`\n\t\treturn view\n\t}\n}\n\nfunction getNewClassString(size: DashContainerOptions, oldClassString: string): string {\n\tif(size)\n\t\toldClassString += \" \" + size\n\treturn oldClassString\n}\n\nexport function DashElement(\n\tsize: DashContainerOptions,\n\t... options: (DashViewOptions | false)[]\n): Vnode<any, any> {\n\tif(options.length == 1) {\n\t\tif(!options[0])\n\t\t\treturn <div></div>\n\t\t\n\t\tconst view =  DashElementView(options[0])\n\t\tview.attrs[\"className\"] = getNewClassString(size, view.attrs[\"className\"])\n\t\treturn view\n\t}\n\telse {\n\t\tconst classString = getNewClassString(size, \"multipleChildren\")\n\t\treturn <div class={classString}>\n\t\t\t{options.map((option) => option && DashElementView(option))}\n\t\t</div>\n\t}\n}","import m, {Vnode} from \"mithril\"\nexport function DashRow(... content: Array<Vnode<any, any> | undefined | false>): Vnode<any, any> {\n\treturn (\n\t\t<div class=\"dashRow\">{content}</div>\n\t)\n}","import m, {Vnode} from \"mithril\"\nimport {Lang} from \"../singletons/Lang\";\nimport androidSvg from \"../../imgs/devices/android.svg?raw\"\nimport iosSvg from \"../../imgs/devices/ios.svg?raw\"\nimport webSvg from \"../../imgs/devices/web.svg?raw\"\nimport {closeDropdown, openDropdown} from \"./DropdownMenu\";\n\n\nexport type PossibleDevices = \"Android\" | \"iOS\" | \"Web\"\n\nconst imageRecord: Record<PossibleDevices, string> = {\n\tAndroid: androidSvg,\n\tiOS: iosSvg,\n\tWeb: webSvg\n}\n\nfunction onPointerEnter(title: string, e: MouseEvent) {\n\topenDropdown(\"notCompatible\", e.target as HTMLElement,\n\t\t() => <div class=\"smallText center\">{title}</div>\n\t)\n}\nfunction onPointerLeave() {\n\tcloseDropdown(\"notCompatible\")\n}\n\nexport function NotCompatibleIcon(... devices: PossibleDevices[]): Vnode<any, any> {\n\tconst translationRecord: Record<PossibleDevices, string> = {\n\t\tAndroid: Lang.get(\"Android\"),\n\t\tiOS: Lang.get(\"iOS\"),\n\t\tWeb: Lang.get(\"web_questionnaire\")\n\t}\n\tconst title = Lang.get(\"not_compatible_with\", devices.map((device) => translationRecord[device]).join(\", \"))\n\treturn <div class=\"notCompatibleIcon\" onpointerenter={onPointerEnter.bind(null, title)} onpointerleave={onPointerLeave.bind(null)}>\n\t\t{devices.map((device) =>\n\t\t\t<div class=\"deviceIcon\">{m.trust(imageRecord[device])}</div>)}\n\t</div>\n\n}\n"],"names":["MerlinTokenType","type","lexeme","line","this","source","start","current","tokens","Array","errors","scanTokens","isAtEnd","scanToken","push","MerlinToken","EOF","hadErrors","length","c","advance","addToken","LEFT_PAREN","RIGHT_PAREN","LEFT_BRACE","RIGHT_BRACE","LEFT_BRACKET","RIGHT_BRACKET","COMMA","COLON","SEMICOLON","MINUS","PLUS","STAR","match","DOT_DOT","DOT","EXCLAMATION_EQUAL","EXCLAMATION","EQUAL_EQUAL","EQUAL","LESS_EQUAL","LESS","GREATER_EQUAL","GREATER_GREATER","GREATER","peek","SLASH","string","isDigit","number","isLetter","identifier","ScanningError","charAt","text","substring","expected","peekNext","startLine","STRING","NUMBER","keywords","IDENTIFIER","test","message","AND","ELSE","ELIF","FALSE","FUNCTION","FOR","IF","IN","INIT","NONE","OBJECT","OR","RETURN","TRUE","WHILE","parse","statements","declaration","function","statement","e","ParseError","synchronize","name","consume","parameters","check","body","block","FunctionStmt","forStatement","ifStatement","returnStatement","whileStatement","initStatement","BlockStmt","assignmentStatement","variable","iterable","expression","ForStmt","branches","condition","thenBranch","Branch","elseBranch","undefined","IfStmt","keyword","previous","value","ReturnStmt","WhileStmt","expr","equals","VariableExpr","AssignStmt","ObjectGetExpr","ObjectSetStmt","obj","ArrayGetExpr","ArraySetStmt","bracket","arr","index","ExpressionStmt","InitStmt","or","and","operator","right","LogicalExpr","equality","comparison","BinaryExpr","term","factor","sequence","unary","colon","sequenceEnd","sequenceStep","SequenceExpr","UnaryExpr","callChain","call","nextFunc","CallExpr","callee","paren","args","finishCall","elements","ArrayExpr","primary","LiteralExpr","ObjectExpr","GroupingExpr","types","some","element","token","Stmt","varName","params","object","Expr","left","end","step","lastValue","extensions","of","updateListener","update","obs","set","state","doc","toString","merlinLinter","oncreate","vNode","attrs","get","createEditor","dom","onupdate","newValue","editor","remove","changes","from","to","insert","parent","initialState","create","view","id","diagnostics","scanner","MerlinScanner","forEach","lineOffsets","severity","parser","MerlinParser","CodeEditor","CodeEditorComponent","DashElementView","options","classString","floatingRight","floating","small","highlight","disabled","content","template","icon","noCompatibilityIcon","class","title","msg","innerLinkTitle","innerLinkHref","href","DashTemplateView","target","startsWith","onclick","showAsClickable","hasOwnProperty","getNewClassString","size","oldClassString","DashElement","map","option","DashRow","imageRecord","Android","iOS","Web","onPointerEnter","onPointerLeave","NotCompatibleIcon","translationRecord","Lang","devices","device","join","onpointerenter","bind","onpointerleave"],"sourceRoot":""}